const authEndpoint = "https://accounts.spotify.com/authorize";

// These are the permissions we are asking the user to grant our application.
const scopes = [
  "user-read-private",
  "user-read-email",
  "user-top-read",
  "user-library-read",
  "playlist-modify-public",
  "playlist-modify-private",
  "user-read-playback-state",     
  "user-read-currently-playing",
   "user-read-recently-played",
];

/**
 * Extracts the access token from the URL hash after a successful
 * redirect from the Spotify authentication page.
 * @returns {string | null} The access token, or null if not found.
 */
export const getTokenFromUrl = (): string | null => {
  if (typeof window === 'undefined') {
    return null;
  }
  
  const hash = window.location.hash;
  if (!hash) {
    return null;
  }

  const token = hash
    .substring(1)
    .split("&")
    .find((elem) => elem.startsWith("access_token"))
    ?.split("=")[1];

  return token || null;
};


/**
 * Constructs the full URL for the Spotify login page, including our
 * client ID, requested scopes, and redirect URI.
 * @returns {string} The fully constructed login URL.
 */
export const getLoginUrl = (): string => {
  const clientId = process.env.NEXT_PUBLIC_SPOTIFY_CLIENT_ID;
  const redirectUri = process.env.NEXT_PUBLIC_REDIRECT_URI;

  if (!clientId || !redirectUri) {
    // In a real app, you might want more robust error handling.
    // For our purposes, logging to the console is sufficient.
    console.error("Spotify Client ID or Redirect URI is not set in .env.local");
    // Return a non-functional link to prevent runtime errors on the server.
    return '#'; 
  }

  // URLSearchParams makes it easy to correctly format the query parameters.
  const params = new URLSearchParams({
    client_id: clientId,
    redirect_uri: redirectUri,
    scope: scopes.join(" "), // Scopes must be a space-separated string.
    response_type: "token",
    show_dialog: "true", // Forces the user to re-approve permissions every time. Good for development.
  });

  return `${authEndpoint}?${params.toString()}`;
};


/**
 * Searches for a track on Spotify.
 * @returns {string | null} The Spotify URI of the first matching track, or null.
 */
export const searchForTrack = async (token: string, trackName: string, artistName: string): Promise<string | null> => {
  const query = `track:${trackName} artist:${artistName}`;
  const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=1`, {
    headers: { 'Authorization': `Bearer ${token}` },
  });
  if (!response.ok) return null;
  const data = await response.json();
  return data.tracks.items[0]?.uri || null;
};

/**
 * Creates a new playlist for the current user.
 * @returns {string | null} The ID of the newly created playlist, or null.
 */
export const createPlaylist = async (token: string, userId: string, playlistName: string): Promise<string | null> => {
  const response = await fetch(`https://api.spotify.com/v1/users/${userId}/playlists`, {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
    body: JSON.stringify({
      name: playlistName,
      description: 'Generated by Find-Tunes AI',
      public: false,
    }),
  });
  if (!response.ok) return null;
  const data = await response.json();
  return data.id;
};

/**
 * Adds a list of tracks to a specified playlist.
 * @returns {boolean} True if successful, false otherwise.
 */
export const addTracksToPlaylist = async (token: string, playlistId: string, trackUris: string[]): Promise<boolean> => {
  // Spotify can only handle 100 tracks per request. We'll send them all for simplicity.
  const response = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
    body: JSON.stringify({ uris: trackUris }),
  });
  return response.ok;
};